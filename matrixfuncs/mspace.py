import numpy as np
from collections import namedtuple


def eigval_multiplicity(M: np.ndarray, eigvals: np.ndarray | None =None, zero_thrsh = 1e-15, rel_eq_thrsh = 1e-8):
  if eigvals is None:
    eigvals = np.linalg.eigvals(M)
  else:
    eigvals = np.array(eigvals)
  nEigvals = eigvals.shape[0]
  non_zero_eigvals = eigvals[abs(eigvals) > zero_thrsh]
  unique_eigvals = [0*eigvals[0]] if non_zero_eigvals.shape != eigvals.shape else []
  for ev in non_zero_eigvals:
    differs = abs(np.array(unique_eigvals)/ev - 1) > rel_eq_thrsh
    if differs.all():
      unique_eigvals.append(ev)
  unique_eigvals = np.array(unique_eigvals)

  alg_mult = [0]*len(unique_eigvals)
  for ev in eigvals:
    alg_mult[abs(unique_eigvals - ev).argmin()] += 1
  alg_mult = np.array(alg_mult)

  def normed_basis(vecs, zero_thrsh=1e-12, eps=1e-128):
    vecs = vecs[np.linalg.norm(vecs, axis=1) > zero_thrsh]
    if np.shape(vecs)[0] <= 1:
      return vecs/(np.linalg.norm(vecs, axis=1)+eps)
    bs = [vecs[0]/(np.linalg.norm(vecs[0], axis=0)+eps)]
    for v in vecs[1:]:
      v0 = v - np.tensordot(np.tensordot(np.conj(bs), v, 1), bs, 1)
      v0_norm = np.linalg.norm(v0)
      if v0_norm < zero_thrsh:
        continue
      bs.append(v0/v0_norm)
    return np.array(bs)
  
  geom_mult = []
  for i, ev in enumerate(unique_eigvals):
    if len(unique_eigvals) == 1:
      ev_thrsh = np.inf
    else:
      other_eigvals = unique_eigvals[np.arange(len(unique_eigvals)) != i]
      ev_thrsh = abs(other_eigvals - ev).min() / 2
    eigvals_ker, eigvecs_ker = np.linalg.eig(M - ev*np.eye(nEigvals))
    inds_ker = abs(eigvals_ker) < ev_thrsh
    vecs_ker = eigvecs_ker[:, inds_ker]
    vecs_ker_min = normed_basis(vecs_ker.T).T
    geom_mult.append(np.shape(vecs_ker_min)[-1])
  geom_mult = np.array(geom_mult)

  Ret = namedtuple('Multiplicity', 'eigvals algebraic geometric'.split())
  ret = Ret(unique_eigvals, alg_mult, geom_mult)
  return ret

class MSpace:
  '''Calculates various objects related to the vector space of some square matrix. (Only works if all eigenvalues are different atm.)

  The krylov space is a vector space generated by a square matrix and the cayley-hamilton theorem
  which states that every square matrix is a root of its own characteristic polynomial. From this
  it follows that A^n is a linear combination of 1=A^0, A, A^2, ..., A^(n-1) and therefore every
  polynomial in A is such a linear combination.

  Attributes
  ----------
  M : array-like
    The matrix which generates the krylov space
  eigvals : array-like
    The eigenvalues of M
  basis : list[array-like]
    Basis of krylov generated by M
  beta : array-like
    A helper vector for solving the recurrence equation. See the documentation for details
  lambdaCoeffs : array-like
    Coefficients of M^n as a vector in the krylov space.
  funcCoeffs : array-like
    A tensor for calculating any matrix function efficiently
  '''

  def __init__(self, M: np.ndarray, eigvals: np.ndarray|None = None):
    self.M = M
    self.eigvals = np.linalg.eigvals(M) if not eigvals else eigvals
    self.eigval_multiplicity = eigval_multiplicity(self.M, self.eigvals)
    self.__normed_basis = MSpace.NormedBasis(self.M)
    self.basis = MSpace.GeneratedBasis(self.M, self.dim)
    self.beta = MSpace.Beta(eigvals=self.eigvals)
    self.lambdaCoeffs = MSpace.Lambda(eigvals=self.eigvals)
    self.funcCoeffs = MSpace.FunctionCoeffs(self.basis, self.beta, self.lambdaCoeffs, self.eigvals)

  @property
  def normed_basis(self):
    return self.__normed_basis

  @property
  def dim(self):
    return len(self.normed_basis)

  @staticmethod
  def sdot(x: np.ndarray, y: np.ndarray):
    shapes = np.shape(x)[-2:] + np.shape(y)[-2:]
    n = shapes[0]
    assert shapes == (n, )*4, 'x and y have to be square matrices of the same size'
    return np.tensordot(np.conj(x), y, ((-2, -1), (-2, -1)))/n

  @staticmethod
  def norm(x: np.ndarray):
    return np.linalg.norm(x, axis=(-2, -1))/np.sqrt(np.shape(x)[-1])
    # return np.sqrt(MSpace.sdot(x, x))

  @staticmethod
  def NormedBasis(M: np.ndarray):
    ret: list[np.ndarray] = [np.eye(M.shape[-1])]
    for _ in range(M.shape[-1]):
      new_val0 = ret[-1]@M
      parallels = MSpace.sdot(ret, new_val0)
      paralell_vec = np.tensordot(ret, parallels, ((0,), (0,)))
      perpendicular_vec = new_val0 - paralell_vec
      norm = MSpace.norm(perpendicular_vec)
      if np.allclose(norm, 0):
        break
      ret.append(perpendicular_vec/norm)
    return ret


  @staticmethod
  def GeneratedBasis(M: np.ndarray, rank: int|None = None):
    '''The list A^0, A^1, ..., A^`rank`. If rank is `None` use the dimension of the matrix.

    Parameters
    ----------
    M : array-like
      A square matrix
    rank : int | None = None
      The rank of `M`
    '''
    if rank is None: rank = M.shape[0]
    ret: list[np.ndarray] = [np.eye(M.shape[0]), M]
    while len(ret) < rank:
      ret.append(ret[-1]@M)
    return ret

  @staticmethod
  def Eigvals_alt(M: np.ndarray | None =None, eigvals: np.ndarray | None =None, multiplicity: np.ndarray | None =None):
    if multiplicity is None:
      multiplicity = eigval_multiplicity(M=M, eigvals=eigvals)
    evs, alg, _ = multiplicity
    nEigvals = np.sum(alg)
    ret = np.zeros((nEigvals, nEigvals), dtype=evs.dtype)
    max_order = np.max(alg)
    inds0 = np.array([sum(alg[:i]) for i in range(len(alg))])
    val0 = np.concat([evs.reshape((-1, 1))**np.arange(nEigvals-1, 0, -1), np.ones((len(evs), 1), dtype=evs.dtype)], axis=1)
    for order in range(1, max_order+1):
      if order == 1:
        inds, val = inds0, val0
      else:
        evs_selection = alg >= order
        inds = (inds0 + order - 1)[evs_selection]
        val1 = val0[evs_selection, (order - 1):]
        val_fac = (np.arange(nEigvals-order+1, 0, -1).reshape((-1,1)) + np.arange(order-1).reshape((1, -1))).prod(axis=-1)
        val = np.concat([val1*val_fac, np.zeros((sum(evs_selection), order - 1), dtype=evs.dtype)], axis=1)
      ret[inds, :] = val
    return ret

  # @staticmethod
  # def Beta0(M: np.ndarray | None =None, eigvals: np.ndarray | None =None):
  #   '''A vector which is perpendicular to e_i*ev_i^m for m=0..n-2 where ev_i are the eigenvalues and n the number of eigenvalues

  #   Parameters
  #   ----------
  #   M : array-like | None = None
  #     A square matrix
  #   eigvals : array-like | None = None
  #     The eigenvalues of `M`
  #   Either `eigvals` or `M` should be specified.
  #   '''
  #   if eigvals is None:
  #     if M is None:
  #       raise ValueError('M or eigvals have to be specified')
  #     else:
  #       eigvals = np.linalg.eigvals(M)
  #   else:
  #     eigvals = np.array(eigvals)
  #   nEigvals = eigvals.shape[0]
  #   if nEigvals == 1: return 1.
  #   if nEigvals == 2: return np.array([1,-1], dtype=eigvals.dtype)

  #   # Q = ([np.ones_like(eigvals), eigvals] + [eigvals**k for k in range(2, nEigvals-1)])[::-1]
  #   # ret = [np.linalg.det([ei]+Q) for ei in np.eye(nEigvals)]

  #   # rets = np.zeros((nEigvals,)*3, dtype=eigvals.dtype)
  #   # rets[:, :, 1:-1] = eigvals.reshape((-1, 1))**np.arange(nEigvals-2, 0, -1)
  #   # rets[:, :, -1] = 1
  #   # rets[:, :, 0] = np.eye(nEigvals)
  #   # ret = np.linalg.det(rets)

  #   rets = np.zeros((nEigvals,)*3, dtype=eigvals.dtype)
  #   rets[:, :, 1:-1] = eigvals.reshape((-1, 1))**np.arange(nEigvals-2, 0, -1)
  #   rets[:, :, -1] = 1
  #   rets[:, :, 0] = np.eye(nEigvals)
  #   ret = np.linalg.det(rets)

  #   return np.array(ret)

  @staticmethod
  def Beta(eigvals_alt: np.ndarray|None=None, eigvals: np.ndarray|None=None, M:np.ndarray|None=None):
    '''beta0/(beta0 @ e_i*ev_i^(n-1)), see also method `MSpace.Beta0`.

    Parameters
    ----------
    beta0 : array-like | None = None
      Beta0
    eigvals : array-like | None = None
      The eigenvalues of `M`
    M : array-like | None = None
      A square matrix
    Either `eigvals` or `M` should be specified. Optionally specify beta0.
    '''
    # if eigvals is None:
    #   if M is None:
    #     raise ValueError('M or eigvals have to be specified')
    #   else:
    #     eigvals = np.linalg.eigvals(M)
    # else:
    #   eigvals = np.array(eigvals)
    # if beta0 is None:
    #   beta0 = MSpace.Beta0(M, eigvals)
    # else:
    #   beta0 = np.array(beta0)

    # nEigvals = eigvals.shape[0]
    # lms = eigvals**(nEigvals-1)
    # ret: np.ndarray = beta0 / (beta0 @ lms)
    # return ret

    nEigvals = eigvals_alt.shape[0]
    ret_buffer = np.zeros((nEigvals,)*3, dtype=eigvals.dtype)
    ret_buffer[:] = eigvals_alt.reshape((1,) + eigvals_alt.shape)
    ret_buffer[:, :, 0] = np.eye(nEigvals)
    ret_normfac = np.linalg.det(eigvals_alt)
    ret0 = np.linalg.det(ret_buffer)
    ret: np.ndarray = ret0 / ret_normfac
    return ret

  @staticmethod
  def Lambda(eigvals: np.ndarray|None=None, M: np.ndarray|None=None, inds: list[int]|int|None=None):
    '''The coefficients of M^n as a vector in the krylov space. There are also equal to the non-trivial negated coeffecients of the characteristic polynomial of `M`
    
    Parameters
    ----------
    eigvals : array-like | None = None
      The eigenvalues of `M`
    M : array-like | None = None
      A square matrix
    inds : list[int] | int | None
      The indices for which the coefficients should be calculated. If `None` all coefficients are calculated.
    Either `eigvals` or `M` should be specified. Optionally specify `inds`.
    '''
    if eigvals is None:
      if M is None:
        raise ValueError('M or eigvals have to be specified')
      else:
        eigvals = np.linalg.eigvals(M)
    else:
      eigvals = np.array(eigvals)
    nEigvals = eigvals.shape[0]
    if inds is None:
      inds = range(nEigvals)
    def getLambdaI(k:int) -> float|complex:
      def multiI():
        js = list(range(nEigvals-k))
        while True:
          yield js
          i = next((i for i in range(1, len(js)+1) if js[-i] < nEigvals-i), None)
          if i is None:
            break
          else:
            js[-i]+=1
            for j in range(-i+1, 0):
              js[j] = js[j-1]+1
      arr = []
      for js in multiI():
        arr.append(-np.prod(-eigvals[js]))
      return np.sum(arr)

    if hasattr(inds, '__iter__'):
      return np.array([getLambdaI(i) for i in inds])
    else:
      return getLambdaI(inds)
    

  @staticmethod
  def FunctionCoeffs(basis: np.ndarray|None=None, beta:np.ndarray|None=None, lambdaCoeffs: np.ndarray|None=None, eigvals: np.ndarray|None=None, **kwargs):
    '''A rank 3 tensor which collects all contraction to efficiently calculate the matrix via tensor contraction.
    In total `f(M)_ij = FunctionCoeffs(..)_ijk f(eigvals_k)`

    Parameters
    ----------
    basis : array-like | None = None
      The list A^0, A^1, ..., A^(n-1)
    beta : array-like | None = None
      Beta
    lambdaCoeffs : array-like | None = None
      Lambda
    eigvals : array-like | None = None
      The eigenvalues of `M`
    Either `eigvals` or `M` should be specified. Optionally specify `basis`, `beta` and `lambdaCoeffs`.
    '''
    if eigvals is None:
      M = kwargs.get('M', None)
      if M is None:
        raise ValueError('M or eigvals have to be specified')
      else:
        eigvals = np.linalg.eigvals(M)
    else:
      eigvals = np.array(eigvals)
    nEigvals = eigvals.shape[0]
    if basis is None:
      basis = MSpace.Basis(eigvals=eigvals, **kwargs)
    if beta is None:
      beta = MSpace.Beta(eigvals=eigvals, **kwargs)
    if lambdaCoeffs is None:
      lambdaCoeffs = MSpace.Lambda(eigvals=eigvals, **kwargs)
    # eigvalTensor = np.array([eigvals**q for q in range(-nEigvals, 0)]).T
    eigvalTensor = eigvals.reshape((-1,1))**np.arange(-nEigvals, 0)
    #eigvalTensorK = lambda k: np.array([eigvals**q for q in range(-k-1, 0)]).T
    eigvalTensorK = lambda k: eigvalTensor[:, nEigvals-k-1:]
    ret : np.ndarray = np.sum([np.outer(basis[k], beta*(eigvalTensorK(k) @ lambdaCoeffs[:k+1])).reshape((nEigvals,)*3) for k in range(nEigvals)], axis=0)
    #ret = np.sum([np.einsum('ij,k,km,m->ijk', basis[k], beta, eigvalTensorK(k), lambdaCoeffs[:k+1]) for k in range(nEigvals)], axis=0)
    return ret

  def __repr__(self) -> str:
    return 'MSpace'+repr(dict(
      M = self.M,
      Eigvals = self.eigvals,
      Basis = self.basis,
      Beta0 = MSpace.Beta0(eigvals=self.eigvals),
      Beta = self.beta,
      Lambda = self.lambdaCoeffs, 
      Coeffs = self.funcCoeffs,
    ))

