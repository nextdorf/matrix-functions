import numpy as np
from collections import namedtuple
import scipy
from .utils import matrix_power_series, Multiplicity, function_coeffs, apply_fn, err
from warnings import warn

def bare_coeffs(tensor: np.ndarray, basis: np.ndarray, assume_normed = False, normalize_to: float|None=1.):
  #TODO This function is unreasonably more stable for normed basis. I suspect a bug somewhere
  if normalize_to is not None and not assume_normed:
    # prod_norms = []
    # for evs in abs(np.linalg.eigvals(basis)):
    #   non_zero = evs[evs > 1e-15]
    #   dim = len(non_zero)
    #   norm = np.prod(non_zero**(1/dim)) if dim > 0 else 1
    #   prod_norms.append(norm)
    # # prod_norms = np.reshape(prod_norms, (-1, ) + (1,)*(len(np.shape(basis))-1))
    # prod_norms = np.array(prod_norms)
    # scale = np.reshape(prod_norms / normalize_to, (-1, 1, 1))
    norms = MSpace.norm(basis)
    scale = np.reshape(norms / normalize_to, (-1, 1, 1))
    scaled_cs = bare_coeffs(tensor, basis / scale, assume_normed=assume_normed, normalize_to=None)
    cs = scaled_cs / np.reshape(scale, (1, -1))
  else:
    cs = MSpace.sdot(basis, tensor)
    if not assume_normed:
      basis_change = MSpace.sdot(basis, basis)
      cs = scipy.linalg.solve(basis_change, cs, assume_a='hermitian')
    cs = np.moveaxis(cs, 0, -1)
  return cs



class MSpace:
  '''Calculates various objects related to the vector space of some square matrix. (Only works if all eigenvalues are different atm.)

  The krylov space is a vector space generated by a square matrix and the cayley-hamilton theorem
  which states that every square matrix is a root of its own characteristic polynomial. From this
  it follows that A^n is a linear combination of 1=A^0, A, A^2, ..., A^(n-1) and therefore every
  polynomial in A is such a linear combination.

  Attributes
  ----------
  M : array-like
    The matrix which generates the krylov space
  eigvals : array-like
    The eigenvalues of M
  basis : list[array-like]
    Basis of krylov generated by M
  beta : array-like
    A helper vector for solving the recurrence equation. See the documentation for details
  lambdaCoeffs : array-like
    Coefficients of M^n as a vector in the krylov space.
  funcCoeffs : array-like
    A tensor for calculating any matrix function efficiently
  '''

  def __init__(self, M: np.ndarray, eigvals: np.ndarray|Multiplicity|None = None):
    def test(name:str, val, ref):
      if not np.allclose(val, ref):
        err_val = err(val, ref)
        warn(f'Error of {name} is high, relative error is {err_val}')

    self.M = np.array(M)
    self.eigvals = (
      np.linalg.eigvals(self.M) if eigvals is None
      else eigvals.full_eigvals if isinstance(eigvals, Multiplicity)
      else eigvals
    )
    self.__normed_basis = MSpace.Normed_Basis(self.M)
    self.multiplicity = Multiplicity.from_matrix(self.M, self.eigvals) if not isinstance(eigvals, Multiplicity) else eigvals
    dim = self.dim
    _dim = np.sum(self.multiplicity.algebraic - self.multiplicity.geometric + 1)
    assert dim == _dim, 'Inconsistent dimension count between basis dimension and eigenvalue multiplicity'
    self.basis = matrix_power_series(self.M, dim)

    self.normed_to_basis = MSpace.sdot(self.normed_basis, self.basis)
    self.basis_to_normed = scipy.linalg.inv(self.normed_to_basis)

    self.f_coeffs, _ = function_coeffs(self.M, self.multiplicity)
    self.phi_coeffs_normed = bare_coeffs(self.f_coeffs, self.normed_basis, assume_normed=True)
    self.phi_coeffs = np.tensordot(self.phi_coeffs_normed, self.basis_to_normed, ((1, ), (1,)))

    _basis = np.tensordot(self.normed_to_basis, self.normed_basis, ((0,), (0,)))
    test('normed_to_basis', self.basis, _basis)
    _n_basis = np.tensordot(self.basis_to_normed, self.basis, ((0,), (0,)))
    test('basis_to_normed', self.normed_basis, _n_basis)
    _fcoeffs_n = np.tensordot(self.phi_coeffs_normed, self.normed_basis, 1)
    test('phi_coeffs_normed', self.f_coeffs, _fcoeffs_n)
    _fcoeffs = np.tensordot(self.phi_coeffs, self.basis, 1)
    test('phi_coeffs', self.f_coeffs, _fcoeffs)

  @property
  def normed_basis(self):
    return self.__normed_basis

  @property
  def dim(self):
    return len(self.normed_basis)

  @staticmethod
  def sdot(x: np.ndarray, y: np.ndarray):
    shapes = np.shape(x)[-2:] + np.shape(y)[-2:]
    n = shapes[0]
    assert shapes == (n, )*4, 'x and y have to be square matrices of the same size'
    ret = np.tensordot(np.conj(x), y, ((-2, -1), (-2, -1)))/n
    return ret

  @staticmethod
  def norm(x: np.ndarray):
    return np.linalg.norm(x, axis=(-2, -1))/np.sqrt(np.shape(x)[-1])

  @staticmethod
  def Normed_Basis(M: np.ndarray, repeat_count = 1):
    # Increased accuracy by applying GS-method thrice didn't improve accuracy 
    ret: list[np.ndarray] = [np.eye(M.shape[-1])]
    for _ in range(1, M.shape[-1]):
      new_val0 = ret[-1]@M
      parallels = MSpace.sdot(ret, new_val0)
      paralell_vec = np.tensordot(ret, parallels, ((0,), (0,)))
      perpendicular_vec = new_val0 - paralell_vec
      norm = MSpace.norm(perpendicular_vec)
      if np.allclose(norm, 0):
        break
      ret.append(perpendicular_vec/norm)

    for _ in range(repeat_count - 1):
      if len(ret) > 2:
        break
      ret0 = ret
      ret = ret0[:2]
      for next_val in ret0[2:]:
        parallels = MSpace.sdot(ret, next_val)
        paralell_vec = np.tensordot(ret, parallels, ((0,), (0,)))
        perpendicular_vec = next_val - paralell_vec
        norm = MSpace.norm(perpendicular_vec)
        if np.allclose(norm, 0):
          break
        ret.append(perpendicular_vec/norm)
    return np.array(ret)

  def __call__(self, f, *dfs, gen_df=None, **kwargs):
    return apply_fn(M=None, f=f, dfs=dfs, gen_df=gen_df, eigvals=self.multiplicity, coeffs=self.f_coeffs, mult_space='min', **kwargs)

  def __repr__(self) -> str:
    ident = ' '*2
    inner = ident + f',\n{ident}'.join((
      f'M: {self.M}',
      f'multiplicity: {self.multiplicity}',
      f'dim: {self.dim}',
      f'basis: {self.basis}',
      f'coeffs: {self.phi_coeffs}'
    ))
    return f'MSpace(\n{inner} )'
