import numpy as np
from collections import namedtuple
import scipy
from .utils import matrix_power_series, Multiplicity, function_coeffs, apply_fn, err
from warnings import warn

def bare_coeffs(tensor: np.ndarray, basis: np.ndarray, assume_normed = False, normalize_to: float|None=1.):
  '''Compute expansion coefficients of `tensor` in terms of `basis` vectors.

  Parameters
  ----------
  tensor : np.ndarray
    The input tensor to decompose.
  basis : np.ndarray
    The basis vectors (assumed to be square matrices).
  assume_normed : bool, optional
    If True, assumes that `basis` is already orthonormal, avoiding unnecessary computations.
  normalize_to : float or None, optional
    If not None, rescales `basis` to have a norm of `normalize_to`.

  Returns
  -------
  np.ndarray
    The expansion coefficients of `tensor` in the `basis`.
  '''

  #TODO This function is unreasonably more stable for normed basis. I suspect a bug somewhere
  if normalize_to is not None and not assume_normed:
    # prod_norms = []
    # for evs in abs(np.linalg.eigvals(basis)):
    #   non_zero = evs[evs > 1e-15]
    #   dim = len(non_zero)
    #   norm = np.prod(non_zero**(1/dim)) if dim > 0 else 1
    #   prod_norms.append(norm)
    # # prod_norms = np.reshape(prod_norms, (-1, ) + (1,)*(len(np.shape(basis))-1))
    # prod_norms = np.array(prod_norms)
    # scale = np.reshape(prod_norms / normalize_to, (-1, 1, 1))
    norms = MSpace.norm(basis)
    scale = np.reshape(norms / normalize_to, (-1, 1, 1))
    scaled_cs = bare_coeffs(tensor, basis / scale, assume_normed=assume_normed, normalize_to=None)
    cs = scaled_cs / np.reshape(scale, (1, -1))
  else:
    cs = MSpace.sdot(basis, tensor)
    if not assume_normed:
      basis_change = MSpace.sdot(basis, basis)
      # cs = scipy.linalg.solve(basis_change, cs, assume_a='hermitian')

      # TODO: Check if this improves the accuracy problem for near-singular matrices
      cond_number = np.linalg.cond(basis_change) # A test to check whether basis_change is almost singular
      if cond_number > 1e12:
        cs = np.linalg.pinv(basis_change) @ cs
      else:
        cs = scipy.linalg.solve(basis_change, cs, assume_a='hermitian')

    cs = np.moveaxis(cs, 0, -1)
  return cs



class MSpace:
  '''Represents a matrix space generated by a given square matrix.
  
  This class provides methods to compute various objects related to the vector space generated by a matrix, including
  an orthonormal basis, eigenvalues, function coefficient tensors, and transformations between different basis representations.

  Attributes
  ----------
  M : np.ndarray
    The input square matrix that generates the space.
  eigvals : np.ndarray
    The eigenvalues of `M`.
  normed_basis : np.ndarray
    The orthonormal basis.
  multiplicity : Multiplicity
    The (algebraic and geometric) multiplicity of the eigenvalues.
  basis : np.ndarray
    The basis of the space generated by `M` repeatedly multiplying `M` with itself.
  normed_to_basis : np.ndarray
    Transformation matrix from the orthonormal basis to the generated basis.
  basis_to_normed : np.ndarray
    Inverse transformation matrix from the generated basis to the orthonormal basis.
  f_coeffs : np.ndarray
    Function coefficients for computing functions of `M`, i.e. `tensordot(multiplicity.map(f), f_coeffs, 1) = f(M)`.
  phi_coeffs_normed : np.ndarray
    Phi coefficients expressed in the orthonormal basis, i.e. `tensordot(phi_coeffs_normed, normed_basis, 1) = f_coeffs`.
  phi_coeffs : np.ndarray
    Phi coefficients expressed in the generated basis, i.e. `tensordot(phi_coeffs, basis, 1) = f_coeffs`.
  '''

  def __init__(self, M: np.ndarray, eigvals: np.ndarray|Multiplicity|None = None):
    '''
    Parameters
    ----------
    M : np.ndarray
      A square matrix generating the space.
    eigvals : np.ndarray, Multiplicity, or None, optional
      If provided, these are the eigenvalues of `M`. If `None`, they are computed automatically.
    '''
    def test(name:str, val, ref):
      if not np.allclose(val, ref):
        err_val = err(val, ref)
        warn(f'Error of {name} is high, relative error is {err_val}')

    self.M = np.array(M)
    self.eigvals = (
      np.linalg.eigvals(self.M) if eigvals is None
      else eigvals.full_eigvals if isinstance(eigvals, Multiplicity)
      else eigvals
    )
    self.__normed_basis = MSpace.Normed_Basis(self.M)
    self.multiplicity = Multiplicity.from_matrix(self.M, self.eigvals) if not isinstance(eigvals, Multiplicity) else eigvals
    dim = self.dim
    _dim = np.sum(self.multiplicity.algebraic - self.multiplicity.geometric + 1)
    assert dim == _dim, 'Inconsistent dimension count between basis dimension and eigenvalue multiplicity'
    self.basis = matrix_power_series(self.M, dim)

    self.normed_to_basis = MSpace.sdot(self.normed_basis, self.basis)
    self.basis_to_normed = scipy.linalg.inv(self.normed_to_basis)

    self.f_coeffs, _ = function_coeffs(self.M, self.multiplicity)
    self.phi_coeffs_normed = bare_coeffs(self.f_coeffs, self.normed_basis, assume_normed=True)
    self.phi_coeffs = np.tensordot(self.phi_coeffs_normed, self.basis_to_normed, ((1, ), (1,)))

    _basis = np.tensordot(self.normed_to_basis, self.normed_basis, ((0,), (0,)))
    test('normed_to_basis', self.basis, _basis)
    _n_basis = np.tensordot(self.basis_to_normed, self.basis, ((0,), (0,)))
    test('basis_to_normed', self.normed_basis, _n_basis)
    _fcoeffs_n = np.tensordot(self.phi_coeffs_normed, self.normed_basis, 1)
    test('phi_coeffs_normed', self.f_coeffs, _fcoeffs_n)
    _fcoeffs = np.tensordot(self.phi_coeffs, self.basis, 1)
    test('phi_coeffs', self.f_coeffs, _fcoeffs)

  @property
  def normed_basis(self):
    'Orthonormal Basis'
    return self.__normed_basis

  @property
  def dim(self):
    'Dimension of the space (rank of the matrix)'
    return len(self.normed_basis)

  @staticmethod
  def sdot(x: np.ndarray, y: np.ndarray):
    '''Compute the scaled inner product (dot product) of two square matrices.

    Parameters
    ----------
    x : np.ndarray
      A square matrix.
    y : np.ndarray
      A square matrix of the same size as `x`.

    Returns
    -------
    np.ndarray
      The scaled inner product of `x` and `y`, defined as `tr(x^t y)/n`

    Raises
    ------
    AssertionError
      If `x` and `y` are not square matrices of the same size.
    '''
    shapes = np.shape(x)[-2:] + np.shape(y)[-2:]
    n = shapes[0]
    assert shapes == (n, )*4, 'x and y have to be square matrices of the same size'
    ret = np.tensordot(np.conj(x), y, ((-2, -1), (-2, -1)))/n
    return ret

  @staticmethod
  def norm(x: np.ndarray):
    'Normalized Frobenius norm of the matrix `x`'
    return np.linalg.norm(x, axis=(-2, -1))/np.sqrt(np.shape(x)[-1])

  @staticmethod
  def Normed_Basis(M: np.ndarray, repeat_count=1):
    '''Compute an orthonormal basis of matrices using the Gram-Schmidt process.
    
    This function applies the Gram-Schmidt (GS) orthogonalization method to the input matrix `M`,
    ensuring that the resulting vectors form an orthonormal basis. The method starts with the the
    identity matrix, and generates the next basis element by multiplying the last basis element
    with `M` and subtracting the span of the previous basis elements. Optionally, the process can
    be repeated multiple times for increased numerical stability.

    Parameters
    ----------
    M : np.ndarray
      The input matrix whose column vectors are to be orthonormalized.
    repeat_count : int, optional (default=1)
      The number of times the Gram-Schmidt process is applied. If `repeat_count` is greater than 1,
      the method is reapplied to refine the basis. However, applying GS multiple times generally does
      not significantly improve accuracy.

    Returns
    -------
    np.ndarray
      A 2D array where each row represents an orthonormal basis vector.
    
    Notes
    -----
    - If the input matrix contains linearly dependent vectors, the basis may have fewer vectors than `M.shape[-1]`.
    - The method relies on the custom `MSpace.sdot` and `MSpace.norm` functions for inner products and vector norms.
    '''
    
    ret: list[np.ndarray] = [np.eye(M.shape[-1])]

    # First pass of Gram-Schmidt orthogonalization
    for _ in range(1, M.shape[-1]):
      new_val0 = ret[-1] @ M
      parallels = MSpace.sdot(ret, new_val0)
      paralell_vec = np.tensordot(ret, parallels, ((0,), (0,)))
      perpendicular_vec = new_val0 - paralell_vec
      norm = MSpace.norm(perpendicular_vec)
      if np.allclose(norm, 0):
        break      
      ret.append(perpendicular_vec / norm)
    
    # Optional: Repeat Gram-Schmidt process for refinement
    for _ in range(repeat_count - 1):
      if len(ret) > 2:
        break
      ret0 = ret
      ret = ret0[:2]
      for next_val in ret0[2:]:
        parallels = MSpace.sdot(ret, next_val)
        paralell_vec = np.tensordot(ret, parallels, ((0,), (0,)))
        perpendicular_vec = next_val - paralell_vec
        norm = MSpace.norm(perpendicular_vec)
        if np.allclose(norm, 0):
          break

        ret.append(perpendicular_vec / norm)

    return np.array(ret)

  def __call__(self, f, *dfs, gen_df=None, **kwargs):
    'See `apply_fn`'
    return apply_fn(M=None, f=f, dfs=dfs, gen_df=gen_df, eigvals=self.multiplicity, coeffs=self.f_coeffs, mult_space='min', **kwargs)

  def __repr__(self) -> str:
    ident = ' '*2
    inner = ident + f',\n{ident}'.join((
      f'M: {self.M}',
      f'multiplicity: {self.multiplicity}',
      f'dim: {self.dim}',
      f'basis: {self.basis}',
      f'coeffs: {self.phi_coeffs}'
    ))
    return f'MSpace(\n{inner} )'
