from typing import Generator
import numpy as np
#import sympy as sp
import symengine as se
import scipy.linalg
from numpy.typing import NDArray
#import multiprocessing
from joblib import delayed, Parallel, cpu_count

def square(x): return x*x
values = Parallel(n_jobs=cpu_count())(delayed(square)(x) for x in range(1000))
type(values)

class SymKrylovSpace:
  '''Calculates various objects related to the krylov space of some square matrix but independent from the representation.

  The krylov space is a vector space generated by a square matrix and the cayley-hamilton theorem
  which states that every square matrix is a root of its own characteristic polynomial. From this
  it follows that A^n is a linear combination of 1=A^0, A, A^2, ..., A^(n-1) and therefore every
  polynomial in A is such a linear combination.

  Attributes
  ----------
  eigvals : Eigvals
    The eigenvalues of M
  beta : array-like
    A helper vector for solving the recurrence equation. See the documentation for details
  lambdaCoeffs : array-like
    Coefficients of M^n as a vector in the krylov space.
  funcCoeffs : array-like
    A tensor for calculating any matrix function efficiently
  '''

  def __init__(self, multiplicity: NDArray[np.integer]):
    self.multiplicity = np.array(multiplicity)
    self.eigvals: list[se.Symbol] = list(se.var(f'\\lambda_1:{len(self.multiplicity) + 1}'))
    self.beta = AbstrKrylovSpace.Beta(eigvals=self.eigvals)
    self.lambdaCoeffs = AbstrKrylovSpace.Lambda(eigvals=self.eigvals)
    self.funcCoeffs = AbstrKrylovSpace.FunctionCoeffs(self.basis, self.beta, self.lambdaCoeffs, self.eigvals)

  @staticmethod
  def LambdaVec(eigvals: list[se.Symbol], multiplicity: NDArray[np.integer], m: se.Symbol = se.var('m')):
    assert len(eigvals) == len(multiplicity)
    ret: list[se.Symbol] = []
    for i in range(len(eigvals)):
      ev = eigvals[i]
      for j in range(multiplicity[i]):
        ret.append((ev**m).diff(ev, j).simplify())
    return se.Matrix([ret]), m

  @staticmethod
  def BetaVec0(eigvals: list[se.Symbol], multiplicity: NDArray[np.integer], lambdaVec: se.Matrix | None = None, m: se.Symbol = se.var('m')):
    n = len(lambdaVec)
    matrix0 = se.Matrix([lambdaVec.subs(m, i) for i in range(n-1)])
    eyeN = se.eye(n)
    beta0: se.Matrix = se.Matrix([[matrix0.col_join(eyeN[i,:]).det() for i in range(n)]])
    beta0.simplify()
    return beta0

  def BetaVec(eigvals: list[se.Symbol], multiplicity: NDArray[np.integer], lambdaVec: se.Matrix | None = None, betaVec0: se.Matrix|None=None, m: se.Symbol = se.var('m')):
    n = len(lambdaVec)
    beta: se.Matrix = betaVec0 / betaVec0.dot(lambdaVec.subs(m, n-1))
    beta.simplify()
    return beta

  @staticmethod
  def Beta0(M: np.ndarray | None =None, eigvals: np.ndarray | None =None):
    '''A vector which is perpendicular to e_i*ev_i^m for m=0..n-2 where ev_i are the eigenvalues and n the number of eigenvalues

    Parameters
    ----------
    M : array-like | None = None
      A square matrix
    eigvals : array-like | None = None
      The eigenvalues of `M`
    Either `eigvals` or `M` should be specified.
    '''
    if eigvals is None:
      if M is None:
        raise ValueError('M or eigvals have to be specified')
      else:
        eigvals = np.linalg.eigvals(M)
    else:
      eigvals = np.array(eigvals)
    nEigvals = eigvals.shape[0]
    if nEigvals == 1: return 1.
    if nEigvals == 2: return np.array([1,-1], dtype=eigvals.dtype)
    Q = ([np.ones_like(eigvals), eigvals] + [eigvals**k for k in range(2, nEigvals-1)])[::-1]
    ret = [np.linalg.det([ei]+Q) for ei in np.eye(nEigvals)]
    return np.array(ret)

  @staticmethod
  def Beta(beta0: np.ndarray|None=None, eigvals: np.ndarray|None=None, M:np.ndarray|None=None):
    '''beta0/(beta0 @ e_i*ev_i^(n-1)), see also method `KrylovSpace.Beta0`.

    Parameters
    ----------
    beta0 : array-like | None = None
      Beta0
    eigvals : array-like | None = None
      The eigenvalues of `M`
    M : array-like | None = None
      A square matrix
    Either `eigvals` or `M` should be specified. Optionally specify beta0.
    '''
    if eigvals is None:
      if M is None:
        raise ValueError('M or eigvals have to be specified')
      else:
        eigvals = np.linalg.eigvals(M)
    else:
      eigvals = np.array(eigvals)
    if beta0 is None:
      beta0 = KrylovSpace.Beta0(M, eigvals)
    else:
      beta0 = np.array(beta0)

    nEigvals = eigvals.shape[0]
    lms = eigvals**(nEigvals-1)
    ret: np.ndarray = beta0 / (beta0 @ lms)
    return ret

  @staticmethod
  def Lambda(eigvals: np.ndarray|None=None, M: np.ndarray|None=None, inds: list[int]|int|None=None):
    '''The coefficients of M^n as a vector in the krylov space. There are also equal to the non-trivial negated coeffecients of the characteristic polynomial of `M`
    
    Parameters
    ----------
    eigvals : array-like | None = None
      The eigenvalues of `M`
    M : array-like | None = None
      A square matrix
    inds : list[int] | int | None
      The indices for which the coefficients should be calculated. If `None` all coefficients are calculated.
    Either `eigvals` or `M` should be specified. Optionally specify `inds`.
    '''
    if eigvals is None:
      if M is None:
        raise ValueError('M or eigvals have to be specified')
      else:
        eigvals = np.linalg.eigvals(M)
    else:
      eigvals = np.array(eigvals)
    nEigvals = eigvals.shape[0]
    if inds is None:
      inds = range(nEigvals)
    def getLambdaI(k:int) -> float|complex:
      def multiI():
        js = list(range(nEigvals-k))
        while True:
          yield js
          i = next((i for i in range(1, len(js)+1) if js[-i] < nEigvals-i), None)
          if i is None:
            break
          else:
            js[-i]+=1
            for j in range(-i+1, 0):
              js[j] = js[j-1]+1
          # if js[-1] < nEigvals-1:
          #   js[-1]+=1
          # elif js[-2] < nEigvals-2:
          #   js[-2]+=1
          #   js[-1]=js[-2]+1
          # #...
          # else:
          #   break
      arr = []
      for js in multiI():
        arr.append(-np.prod(-eigvals[js]))
      return np.sum(arr)

    if hasattr(inds, '__iter__'):
      return np.array([getLambdaI(i) for i in inds])
    else:
      return getLambdaI(inds)
    
  @staticmethod
  def FunctionCoeffs(basis: np.ndarray|None=None, beta:np.ndarray|None=None, lambdaCoeffs: np.ndarray|None=None, eigvals: np.ndarray|None=None, **kwargs):
    '''A rank 3 tensor which collects all contraction to efficiently calculate the matrix via tensor contraction.
    In total `f(M)_ij = FunctionCoeffs(..)_ijk f(eigvals_k)`

    Parameters
    ----------
    basis : array-like | None = None
      The list A^0, A^1, ..., A^(n-1)
    beta : array-like | None = None
      Beta
    lambdaCoeffs : array-like | None = None
      Lambda
    eigvals : array-like | None = None
      The eigenvalues of `M`
    Either `eigvals` or `M` should be specified. Optionally specify `basis`, `beta` and `lambdaCoeffs`.
    '''
    if eigvals is None:
      M = kwargs.get('M', None)
      if M is None:
        raise ValueError('M or eigvals have to be specified')
      else:
        eigvals = np.linalg.eigvals(M)
    else:
      eigvals = np.array(eigvals)
    nEigvals = eigvals.shape[0]
    if basis is None:
      basis = KrylovSpace.Basis(eigvals=eigvals, **kwargs)
    if beta is None:
      beta = KrylovSpace.Beta(eigvals=eigvals, **kwargs)
    if lambdaCoeffs is None:
      lambdaCoeffs = KrylovSpace.Lambda(eigvals=eigvals, **kwargs)
    eigvalTensor = np.array([eigvals**q for q in range(-nEigvals, 0)]).T
    #eigvalTensorK = lambda k: np.array([eigvals**q for q in range(-k-1, 0)]).T
    eigvalTensorK = lambda k: eigvalTensor[:, nEigvals-k-1:]
    ret : np.ndarray = np.sum([np.outer(basis[k], beta*(eigvalTensorK(k) @ lambdaCoeffs[:k+1])).reshape((nEigvals,)*3) for k in range(nEigvals)], axis=0)
    #ret = np.sum([np.einsum('ij,k,km,m->ijk', basis[k], beta, eigvalTensorK(k), lambdaCoeffs[:k+1]) for k in range(nEigvals)], axis=0)
    return ret

  def __repr__(self) -> str:
    return 'KrylovSpace'+repr(dict(
      M = self.M,
      Eigvals = self.eigvals,
      Basis = self.basis,
      Beta0 = KrylovSpace.Beta0(self.eigvals),
      Beta = self.beta,
      Lambda = self.lambdaCoeffs, 
      Coeffs = self.funcCoeffs,
    ))

