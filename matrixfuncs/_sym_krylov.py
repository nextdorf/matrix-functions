import numpy as np
import sympy as sp
from scipy.special import comb
from numpy.typing import NDArray
from joblib import delayed, Parallel, cpu_count

import sys
gettrace = getattr(sys, 'gettrace', None)
_inDebugMode = gettrace and gettrace() is not None


def normalOrderOp(permOld: list[int], permNew: list[int]):
  assert len(permOld) == len(permNew)
  op = {i: permNew[i] for i in range(len(permNew)) if permNew[i] != permOld[i]}
  return op

def normalOrderPerm(perm: list[int]):
  zipped = sorted(zip(range(len(perm)), perm), key=lambda x: -x[1])
  indPerm, ordPerm = map(list, zip(*zipped))
  return indPerm, ordPerm

def normalOrderOpFrom(perm: list[int]):
  indPerm, ordPerm = normalOrderPerm(perm)
  return normalOrderOp(range(len(indPerm)), indPerm), normalOrderOp(perm, ordPerm)

def normalOrderOpTo(perm: list[int]):
  indPerm, ordPerm = normalOrderPerm(perm)
  return normalOrderOp(indPerm, range(len(indPerm))), normalOrderOp(ordPerm, perm)


class SymKrylovSpaceCache:
  def __init__(self):
    self.value: dict[tuple[int, ...], SymKrylovSpace] = {}
  def __getitem__(self, perm: tuple[int, ...]):
    perm = list(perm) if hasattr(perm, '__iter__') else [perm]
    if len(perm) == 0: return SymKrylovSpace([])
    indsPerm0: tuple[tuple[int, ...], tuple[int, ...]] = map(tuple, normalOrderPerm(perm))
    inds0, perm0 = indsPerm0
    indsMult0 = []
    for i in range(len(perm)):
      i0 = np.sum(perm[:i], dtype=int)
      indsMult0 += [list(range(i0, i0+perm[i]))]
    indsMult0 = list(np.concatenate([indsMult0[i] for i in inds0])) #permutation of perm
    _, indsMult0 = map(list, zip(*sorted(zip(indsMult0, range(len(indsMult0))), key=lambda x: x[0]))) #inverse permutation of perm
    ret = SymKrylovSpace([])
    if perm0 not in self.value:
      self.value[perm0] = SymKrylovSpace(perm0)
    sk = self.value[perm0]
    ret.multiplicity = np.array(perm)
    permTo = normalOrderOp(range(len(perm)), list(inds0))
    tmpVars = sp.Array(sp.var(f'\\lambda1:{len(perm)+1}^{{(tmp)}}'))
    subL1 = [(sk.eigvals[iFrom], tmpVars[iFrom]) for iFrom, iTo in permTo.items()]
    subL2 = [(tmpVars[iFrom], sk.eigvals[iTo]) for iFrom, iTo in permTo.items()]
    ret.eigvals = sk.eigvals.copy()
    ret.mVar = sk.mVar
    for attrName in 'lambdaVec betaVec betaM lambdaCoeffs funcCoeffs'.split():
      attr: sp.Array = getattr(sk, attrName)
      attr = attr.subs(subL1).subs(subL2)
      setattr(ret, attrName, attr)
    for attrName in 'lambdaVec betaVec'.split():
      attr: sp.Array = getattr(ret, attrName)
      attr = sp.Array(np.array(attr)[indsMult0])
      setattr(ret, attrName, attr)
    for attrName in 'betaM funcCoeffs'.split():
      attr: sp.Array = getattr(ret, attrName)
      attr = sp.Array(np.array(attr)[...,inds0,:])
      setattr(ret, attrName, attr)
    return ret

  def __str__(self) -> str:
    return f'SymKrylovSpaceCache{list(self.value)}'
  def __repr__(self) -> str:
    return str(self)


class SymKrylovSpace:
  '''Calculates various objects related to the krylov space of some square matrix but independent from the representation.

  The krylov space is a vector space generated by a square matrix and the cayley-hamilton theorem
  which states that every square matrix is a root of its own characteristic polynomial. From this
  it follows that A^n is a linear combination of 1=A^0, A, A^2, ..., A^(n-1) and therefore every
  polynomial in A is such a linear combination.

  Attributes
  ----------
  eigvals : Eigvals
    The eigenvalues of M
  beta : array-like
    A helper vector for solving the recurrence equation. See the documentation for details
  lambdaCoeffs : array-like
    Coefficients of M^n as a vector in the krylov space.
  funcCoeffs : array-like
    A tensor for calculating any matrix function efficiently
  '''

  def __init__(self, multiplicity: NDArray[np.integer]| int, *additionalMults: int):
    if additionalMults:
      if hasattr(multiplicity, '__iter__'):
        multiplicity = list(multiplicity) + list(additionalMults)
      else:
        multiplicity = list((multiplicity,) + additionalMults)
    elif not hasattr(multiplicity, '__iter__'):
      multiplicity = [multiplicity]

    self.multiplicity = np.array(multiplicity)
    if len(self.multiplicity) > 0:
      if len(self.multiplicity) == 1:
        self.eigvals: sp.Array = sp.Array([sp.var('\\lambda')])
      else:
        self.eigvals: sp.Array = sp.Array(sp.var(f'\\lambda_1:{len(self.multiplicity) + 1}'))
      self.lambdaVec, self.mVar = SymKrylovSpace.LambdaVec(self.eigvals, self.multiplicity)
      self.betaVec = SymKrylovSpace.BetaVec(self.lambdaVec, eigvals=self.eigvals)
      self.betaM = SymKrylovSpace.BetaM(self.multiplicity, self.betaVec, self.eigvals)
      self.lambdaCoeffs = SymKrylovSpace.LambdaCoeffs(self.eigvals, self.multiplicity)
      self.funcCoeffs = SymKrylovSpace.FunctionCoeffs(self.eigvals, self.multiplicity, self.betaM, self.lambdaCoeffs)
    else:
      self.mVar = sp.var('m')
      for attr in 'eigvals lambdaVec betaVec betaM lambdaCoeffs funcCoeffs'.split():
        setattr(self, attr, sp.Array([]))

  @staticmethod
  def LambdaVec(eigvals: sp.Array, multiplicity: NDArray[np.integer], m: sp.Symbol = sp.var('m')) -> tuple[sp.Array, sp.Symbol]:
    assert len(eigvals) == len(multiplicity)
    ret: list[sp.Symbol] = []
    for i in range(len(eigvals)):
      ev = eigvals[i]
      for j in range(multiplicity[i]):
        ret.append((ev**m).diff(ev, j).simplify())
    return sp.Array(ret), m

  @staticmethod
  def BetaVec0(lambdaVec: sp.Array|None = None, eigvals: sp.Array|None = None, multiplicity: NDArray[np.integer]|None=None, m: sp.Symbol = sp.var('m')):
    if lambdaVec is None:
      lambdaVec,_ = SymKrylovSpace.LambdaVec(eigvals, multiplicity, m)
    n = len(lambdaVec)
    if multiplicity is not None:
      assert n == np.sum(multiplicity)
    matrix0 = sp.Matrix([lambdaVec.subs(m, i) for i in range(n-1)])
    eyeN = sp.eye(n)
    if _inDebugMode:
      beta0: sp.Array = sp.Array([
        matrix0.col_join(eyeN[i,:]).det().simplify().factor() for i in range(n)
        ])
    else:
      beta0: sp.Array = sp.Array(Parallel(n_jobs=cpu_count())(delayed(
          lambda i: matrix0.col_join(eyeN[i,:]).det().simplify().factor()
        )(i) for i in range(n)))
    return beta0

  @staticmethod
  def BetaVec(lambdaVec: sp.Array|None=None, betaVec0: sp.Array|None=None, eigvals: sp.Array|None=None, multiplicity: NDArray[np.integer]|None = None, m: sp.Symbol = sp.var('m')) -> sp.Array:
    if lambdaVec is None:
      lambdaVec,_ = SymKrylovSpace.LambdaVec(eigvals, multiplicity, m)
    if betaVec0 is None:
      betaVec0 = SymKrylovSpace.BetaVec0(lambdaVec, eigvals, multiplicity, m)
    n = len(lambdaVec)
    if multiplicity is not None:
      assert n == np.sum(multiplicity)
    #beta: sp.Array = betaVec0 / sp.tensorcontraction(sp.tensorproduct(betaVec0, lambdaVec.subs(m, n-1)), (0,1)).simplify()
    beta: sp.Array = betaVec0 / (np.array(betaVec0.tolist()) @ lambdaVec.subs(m, n-1).tolist()).factor()
    return beta.simplify()

  @staticmethod
  def BetaM(multiplicity: NDArray[np.integer]|None=None, betaVec: sp.Array|None=None, eigvals: sp.Array|None=None, betaVec0: sp.Array|None=None, lambdaVec: sp.Array|None=None, m: sp.Symbol = sp.var('m')) -> sp.Array:
    if betaVec is None:
      betaVec = SymKrylovSpace.BetaVec(lambdaVec, betaVec0, eigvals, multiplicity, m)
    multMax = np.max(multiplicity)
    betaVecL = betaVec.tolist()
    beta = []
    m0 = 0
    for mi in multiplicity:
      row = betaVecL[m0:m0+mi]
      if mi < multMax:
        row += [0]*(multMax-mi)
      beta.append(row)
      m0+=mi
    return sp.Array(beta)


  @staticmethod
  def LambdaCoeffs(eigvals: sp.Array, multiplicity: NDArray[np.integer]) -> sp.Array:
    '''The coefficients of M^n as a vector in the krylov space. There are also equal to the non-trivial negated coeffecients of the characteristic polynomial of `M`
    
    Parameters
    ----------
    eigvals : array-like | None = None
      The eigenvalues of `M`
    M : array-like | None = None
      A square matrix
    inds : list[int] | int | None
      The indices for which the coefficients should be calculated. If `None` all coefficients are calculated.
    Either `eigvals` or `M` should be specified. Optionally specify `inds`.
    '''
    t = sp.var('t')
    charPolyNeg: sp.Poly = -sp.Poly(sp.prod([(t-eigvals[i])**multiplicity[i] for i in range(len(eigvals))]), t)
    return sp.Array(charPolyNeg.all_coeffs()[1:][::-1])
    

    
  @staticmethod
  def FunctionCoeffs(eigvals: sp.Array, multiplicity: NDArray[np.integer], betaM: sp.Array|None=None, lambdaCoeffs: sp.Array|None=None, **kwargs):
    '''A rank 3 tensor which collects all contraction to efficiently calculate the matrix via tensor contraction.
    In total `f(M)_ij = FunctionCoeffs(..)_ijk f(eigvals_k)`

    Parameters
    ----------
    basis : array-like | None = None
      The list A^0, A^1, ..., A^(n-1)
    beta : array-like | None = None
      Beta
    lambdaCoeffs : array-like | None = None
      Lambda
    eigvals : array-like | None = None
      The eigenvalues of `M`
    Either `eigvals` or `M` should be specified. Optionally specify `basis`, `beta` and `lambdaCoeffs`.
    '''
    n = np.sum(multiplicity)
    maxMult = np.max(multiplicity)
    if lambdaCoeffs is None:
      lambdaCoeffs = SymKrylovSpace.LambdaCoeffs(eigvals, multiplicity)
    if betaM is None:
      betaM = SymKrylovSpace.BetaM(multiplicity, eigvals=eigvals)

    def getElem(k,l,q):
      js = np.arange(k+1)
      ps = np.arange(q, multiplicity[l])
      t1 = np.array(lambdaCoeffs[k::-1].tolist()) #(kj)
      t2 = np.array(betaM[l, ps[0]:ps[-1]+1].tolist()) #(lp)
      t3 = np.outer(np.ones_like(js), np.array([comb(p, q, exact=True) for p in ps])*(-1)**(ps-q)) * np.array([[np.arange(j+1, j+1+p-q).prod() for p in ps] for j in js]) #(jp)
      t4 = np.array([[eigvals[l]**-(j+1+p-q) for p in ps] for j in js]) #(jp)
      res = (t1 @ (t3*t4) @ t2).simplify().factor()
      return res
    ret: sp.Array = sp.Array(
      [
        [
          [
            getElem(k,l,q)
            for q in range(multiplicity[l])]
          + [0]*(maxMult - multiplicity[l])
          for l in range(len(eigvals))]
        for k in range(n)]
      )
    return ret

  def __repr__(self) -> str:
    evs = ', '.join(map(str, self.multiplicity))
    return f'SymKrylov[ var: {self.mVar}, multiplicity: ({evs}) ]' if evs else 'SymKrylov[]'
  def _repr_latex_(self) -> str:
    evs = ',\\ '.join([f'{ev}\\; ({i})' for ev, i in zip(self.eigvals, self.multiplicity)])
    return f'SymKrylov[ var: ${self.mVar}$, eigvals: ${evs}$ ]' if evs else 'SymKrylov[]'



